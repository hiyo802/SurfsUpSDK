@tool
class_name CSGRamp
extends CSGPolygon3D

# --- Conversion Constants --- maybe have as global if don't already
const HAMMER_UNITS_PER_METER = 39.37 # 1 Godot unit (meter) = 39.37 Hammer Units
const METERS_PER_HAMMER_UNIT = 1.0 / HAMMER_UNITS_PER_METER

enum PathBehavior {
	STRAIGHT,
	CURVE_UP,
	CURVE_DOWN
}

@export_subgroup("Ramp Settings")
@export_range(45.573, 65.5, 0.001, "suffix:deg") var Surf_Angle: float = 45.573:
	set(value):
		Surf_Angle = value
		update_array()

@export_range(2.0, 1024.0, 1.0, "suffix:u") var ramp_height_hammer_units: float = 256.0:
	set(value):
		ramp_height_hammer_units = clampf(value, 2.0, 1024.0) 
		_ramp_height_godot_units = ramp_height_hammer_units * METERS_PER_HAMMER_UNIT
		update_clipping_ratios()
		setup_path_node()
		update_array()

var _ramp_height_godot_units: float

@export_range(2.0, 10240.0, 1.0, "suffix:u") var ramp_length_hammer_units: float = 512.0:
	set(value):
		ramp_length_hammer_units = clampf(value, 2.0, 10240.0)
		_ramp_length_godot_units = ramp_length_hammer_units * METERS_PER_HAMMER_UNIT
		setup_path_node()
		update_array()

var _ramp_length_godot_units: float = ramp_length_hammer_units * METERS_PER_HAMMER_UNIT

@export var two_sided: bool = false:
	set(value):
		two_sided = value
		update_array()
		
@export var path_behavior: PathBehavior = PathBehavior.STRAIGHT:
	set(value):
		path_behavior = value
		setup_path_node()
		update_array()
@export_subgroup("Clipping Settings")
@export var clip_top: bool = false:
	set(value):
		clip_top = value
		update_array()

@export_range(2.0, 64.0, 1.0, "suffix:u") var clip_top_amount_hammer_units: float = 32.0:
	set(value):
		clip_top_amount_hammer_units = clampf(value, 2.0, 64.0) 
		update_clipping_ratios() 
		update_array()

var _clip_top_amount_ratio: float

@export var clip_bottom: bool = false:
	set(value):
		clip_bottom = value
		update_array()

@export_range(2.0, 64.0, 1.0, "suffix:u") var clip_bottom_amount_hammer_units: float = 32.0:
	set(value):
		clip_bottom_amount_hammer_units = clampf(value, 1.0, 64.0)
		update_clipping_ratios()
		update_array()

var _clip_bottom_amount_ratio: float

@export_subgroup("Path Modifiers")
@export_range(0.01, 1.0, 0.01) var curviness: float = 0.1:
	set(value):
		curviness = clampf(value, 0.05, 1.0) 
		setup_path_node()
@export_range(1.7, 4.5, 0.05) var steepness: float = 3.0:
	set(value):
		steepness = clampf(value, 1.7, 4.5) 
		setup_path_node()

@onready var triArray: PackedVector2Array 
@onready var path_node_3d: Path3D

func _enter_tree() -> void:
	_ramp_height_godot_units = ramp_height_hammer_units * METERS_PER_HAMMER_UNIT
	update_clipping_ratios()
	setup_path_node()
	update_array()
	
func _ready() -> void:
	mode = CSGPolygon3D.MODE_PATH
	path_rotation = CSGPolygon3D.PATH_ROTATION_PATH
	path_local = true
	path_interval = 0.3
	use_collision = true
	_ramp_height_godot_units = ramp_height_hammer_units * METERS_PER_HAMMER_UNIT
	_ramp_length_godot_units = ramp_length_hammer_units * METERS_PER_HAMMER_UNIT
	update_clipping_ratios()
	update_array()

func _notification(what: int) -> void:
	match what:
		NOTIFICATION_POST_ENTER_TREE:
			_ramp_height_godot_units = ramp_height_hammer_units * METERS_PER_HAMMER_UNIT
			update_clipping_ratios()
			setup_path_node()
			update_array()

func update_clipping_ratios():
	var top_clip_godot_units = clip_top_amount_hammer_units * METERS_PER_HAMMER_UNIT
	var calculated_top_ratio = top_clip_godot_units / max(0.001, _ramp_height_godot_units)
	_clip_top_amount_ratio = clampf(calculated_top_ratio, 0.01, 0.30)

	var bottom_clip_godot_units = clip_bottom_amount_hammer_units * METERS_PER_HAMMER_UNIT
	var calculated_bottom_ratio = bottom_clip_godot_units / max(0.001, _ramp_height_godot_units)
	_clip_bottom_amount_ratio = clampf(calculated_bottom_ratio, 0.01, 0.30)


func update_array():
	triArray = get_right_triangle_polygon_2d(
		deg_to_rad(Surf_Angle), 
		_ramp_height_godot_units,
		clip_top, 
		_clip_top_amount_ratio, 
		clip_bottom, 
		_clip_bottom_amount_ratio,
		two_sided
	)
	polygon = triArray
	
func setup_path_node():
	if path_node_3d == null || !is_instance_valid(path_node_3d):
		for child in get_children():
			if child is Path3D:
				path_node_3d = child
				break
		
		if path_node_3d == null:
			path_node_3d = Path3D.new()
			path_node_3d.name = "AutoGeneratedPath"
			
			if Engine.is_editor_hint():
				add_child(path_node_3d, true) 
				path_node_3d.owner = get_tree().edited_scene_root
			else:
				add_child(path_node_3d)
	
	if path_node_3d:
		var curve = Curve3D.new()
		var end_point_pos = Vector3(0, 0, -_ramp_length_godot_units)

		match path_behavior:
			PathBehavior.STRAIGHT:
				curve.add_point(Vector3.ZERO)
				curve.add_point(end_point_pos)
			PathBehavior.CURVE_UP:
				# Tangents relative to the point. Y will make it curve up/down. Z will make it curve forward/backward.
				# `in_tangent` affects the curve coming *into* the point.
				# `out_tangent` affects the curve going *out of* the point.
				
				# For the start point (0,0,0)
				var start_out_tangent_y = curviness * _ramp_length_godot_units
				var start_out_tangent_z = _ramp_length_godot_units / -steepness
				
				# For the end point (0,0,-length)
				var end_in_tangent_y = curviness * _ramp_length_godot_units
				var end_in_tangent_z = _ramp_length_godot_units / steepness
				
				curve.add_point(Vector3.ZERO, Vector3.ZERO, Vector3(0, start_out_tangent_y, start_out_tangent_z))
				curve.add_point(end_point_pos, Vector3(0, end_in_tangent_y, end_in_tangent_z), Vector3.ZERO)
			PathBehavior.CURVE_DOWN:
				var start_out_tangent_y = -curviness * _ramp_length_godot_units
				var start_out_tangent_z = _ramp_length_godot_units / -steepness
				
				var end_in_tangent_y = -curviness * _ramp_length_godot_units
				var end_in_tangent_z = _ramp_length_godot_units / steepness
				
				curve.add_point(Vector3.ZERO, Vector3.ZERO, Vector3(0, start_out_tangent_y, start_out_tangent_z))
				curve.add_point(end_point_pos, Vector3(0, end_in_tangent_y, end_in_tangent_z), Vector3.ZERO)

		path_node_3d.curve = curve
		path_node = path_node_3d.get_path()

func get_right_triangle_polygon_2d(angle_rad: float, height: float, do_clip_top: bool, clip_top_ratio: float, do_clip_bottom: bool, clip_bottom_ratio: float, two_sided: bool) -> PackedVector2Array:
	var points := PackedVector2Array()
	
	var original_base_AC = height / tan(angle_rad)

	# --- Apply the halving for two-sided top clip to the ratio ---
	var effective_clip_top_ratio = clip_top_ratio
	if two_sided:
		effective_clip_top_ratio *= 0.5 # Halve the ratio when two-sided

	# --- Calculate Clipped Top Dimensions ---
	var current_height = height
	if do_clip_top and effective_clip_top_ratio > 0.0:
		current_height = height * (1.0 - effective_clip_top_ratio)
		current_height = max(current_height, height * 0.01) #safety

	var top_slanted_x = current_height * (original_base_AC / height) - original_base_AC

	# --- Calculate Clipped Bottom Dimensions ---
	var current_bottom_left_x = -original_base_AC
	var bottom_slanted_y = 0.0

	if do_clip_bottom and clip_bottom_ratio > 0.0:
		current_bottom_left_x = -original_base_AC * (1.0 - clip_bottom_ratio)
		current_bottom_left_x = min(current_bottom_left_x, -0.001) # safety

		bottom_slanted_y = (height / original_base_AC) * (current_bottom_left_x + original_base_AC)
		bottom_slanted_y = max(0.0, bottom_slanted_y) # safety

	# --- Assemble the Polygon Points ---
	""" for anyone reading we always assemble clockwise
			B2__B
			/  /|
		   /  / |
		  /  /  |
		 /  /   |
		/  /    |
	   /  /     |
	A2/  /      |
	  | /       |
	  A---------C--- [X]
				| (0, 0)
			   [Y]"""


	if two_sided:
		# 1. Leftmost point on the bottom base
		points.append(Vector2(current_bottom_left_x, 0))

		# 2. Top of the left vertical cut (if bottom clipped)
		if do_clip_bottom and clip_bottom_ratio > 0.0:
			points.append(Vector2(current_bottom_left_x, bottom_slanted_y))

		# 3. Top-left point on the slanted face
		points.append(Vector2(top_slanted_x, current_height))

		# 4. Top center point (on Y-axis) - only if it's a distinct corner
		if abs(top_slanted_x) > 0.001: 
			points.append(Vector2(0, current_height))
		
		# 5. Top-right point on the slanted face (mirrored of 3)
		points.append(Vector2(-top_slanted_x, current_height))

		# 6. Top of the right vertical cut (if bottom clipped, mirrored of 2)
		if do_clip_bottom and clip_bottom_ratio > 0.0:
			points.append(Vector2(-current_bottom_left_x, bottom_slanted_y))

		# 7. Rightmost point on the bottom base (mirrored of 1)
		points.append(Vector2(-current_bottom_left_x, 0))

		# 8. Bottom center point (on Y-axis) - only if it's a distinct corner
		if abs(current_bottom_left_x) > 0.001:
			points.append(Vector2(0, 0)) # Point C (0,0)

	else:
		# 1. Bottom-Right Corner (Always (0,0) - Point C)
		points.append(Vector2(0, 0))

		# 2 & 3: Bottom-Left part (either original Point A, or the flat bottom + vertical cut)
		if do_clip_bottom and clip_bottom_ratio > 0.0:
			points.append(Vector2(current_bottom_left_x, 0))
			points.append(Vector2(current_bottom_left_x, bottom_slanted_y))
		else:
			points.append(Vector2(-original_base_AC, 0)) # Original Point A

		# 4. Top-Left Corner (on slanted edge, at 'current_height')
		points.append(Vector2(top_slanted_x, current_height))

		# 5. Top-Right Corner (on Y-axis, at 'current_height')
		points.append(Vector2(0, current_height))

	# Fallback for invalid polygons (less than 3 points)
	if points.size() < 3:
		points.clear()
		points.append(Vector2(0, 0))
		points.append(Vector2(-original_base_AC, 0))
		points.append(Vector2(0, height))

	return points
